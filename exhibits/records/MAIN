MAIN
C 
C  GRAPHICAL PROGRAMMING LANGUAGE 
C  AN EXPERIMENT IN GRAPHICAL CONTROL STRUCTURES
C  HOWARD CUNNINGHAM, OCTOBER 1976
C 
C  CODING CONVENTIONS 
C  ------------------ 
C 
C        ALL INTEGER VARIABLES WILL BE PREFIXED WITH I THROUGN N. 
C     THESE PREFIXES ARE FURTHER SUBDIVIDED AS FOLLOWS: 
C 
C        I - INDEX INTO DATA BASE 
C        J - FORMAL PARAMETER 
C        K - CONSTANT 
C        L - ARRAY
C        M - MAXIMUM BOUND
C        N - INTEGER NUMBER 
C 
C        STATEMENT NUMBERS WILL BE ASSIGNED IN ASSENDING
C     ORDER.  AN INCREMENT IN THE HUNDREDS PLACE WILL 
C     INDICATE A NEW FUNCTIONAL BLOCK.
C 
C        A COMMON BLOCK WILL BE DEFINED IDENTICALLY IN ALL
C     ROUTINES IN WHICH IT IS USED. 
C 
C  LIBRARY ROUTINES USED
C  ---------------------
C 
C     SETUP - INITIALIZE GRAPHICS PACKAGE 
C     BLANK - CLEAR SEGMENT 
C     MOUSE - READ MOUSE POSITION 
C     DELFIL - DELETE FILE ASSIGNED TO SPECIFIED UNIT 
C     IDAS - READ CHANNEL OF A TO D CONVERTER 
C     MOVE - MOVE (TRANSLATE) A DISPLAY SEGMENT 
C     DIM - ADJUST SEGMENT INTENSITY
C     MARK - RECORD SEGMENT STATUS
C     SEG - CREATE NEW SEGMENT
C     CIRCLE - PLOT CIRCLE
C     RESET - RESTORE SEGMENT TO SAVED STATE
C     APPEND - OPEN SEGMENT WITHOUT ERASE 
C     STRING - PLOT TEXT USING 'HARDWARE' CHARACTERS
C     INTSTY - ADJUST REMAINING SEGMENT INTENSITY 
C     KEYBRD - READ TERMINAL KEYBOARD 
C     KEYSET - READ FUNCTION KEYSET 
C     ASSIGN - CHANGE FILE NAME ASSIGNMENT FOR SPECIFIED UNIT 
C 
C  BUGS AND LIMITATIONS 
C  -------------------- 
C 
C        SHOULD INHIBIT TEXT ENTRY FOR OFF-PAGE NODES.
C 
C        CANNOT REMOVE LAST STATEMENT OF A CLAUSE.  SHOULD APPLY
C     TO SINGLE STATEMENT CLAUSES ONLY. 
C 
C        CONTRACT SAVES ONLY FIRST STATEMENT OF CLAUSE. 
C 
C        RECURSIVE ZOOM CAN MODIFY SAVED PROGRAM VOIDING
C     POINTERS ON THE STACK.
C 
C        POINTER RELOCATION REQUIRED TO KEEP STATEMENTS ACROSS
C     PROGRAM BOUNDRYS. 
C 
C        GENOUT WILL NOT GENERATE CONTINUATION CARDS WHEN 
C     COLUMN 72 IS EXCEEDED.  THIS CAN EASILY HAPPEN ON THE 
C     COMPUTED GOTO FOR A LARGE CASE STATEMENT. 
C 
C        SUBROUTINE SHARE SHOULD ALLOCATE LESS VERTICAL SPACE 
C     TO TYPE 1 STATEMENTS THAN OTHERS. 
C 
C  PROGRAM ERROR HALTS
C  -------------------
C 
C     1 - COUNT, CIRCULAR LINKS 
C     2 - SETALL, CIRCULAR LINKS
C     3 - SHARE, COUNT ZERO OR WRONG
C     4 - FORM, MISSING TERMINATOR
C     5 - PUSH, STACK OVERFLOW
C     6 - PULL, STACK UNDERFLOW 
C     7 - DRAW, LINK TO NON-ALLOCATED NODE
C     10 - FORM, IMPROPER BOUNDS
C     11 - ALLOC, NO FREE SEGMENTS
C     12 - FREE, RETURN OF NON-ALLOCATED SEGMENT
C     16 - NEWNOD, NO FREE NODES
C     17 - INCMND, CIRCULAR LINKS 
C     20 - FRENOD, FREE OF UNALLOCATED NODE 
C     21 - REFREP, NO REFERENCE TO NODE 
C     22 - LOADER, INPUT RANGE ERROR
C     23 - LOADER, TOO MUCH DATA
C     24 - RENAME, NAME SIZE ERROR
C     25 - LOADER, NO ROOT
C     26 - REFREP, COMPOUNDING BROTHER LINKS
C     28 - GENOUT, EMPTY OUTPUT LINE
C     29 - ZOOM, STACK REFERENCE TO NON-ALLOCATED NODE. 
C 
*CALL,DATA
*CALL,FILE
C 
      CALL SETUP
      CALL PUSH(0)
      CALL RENAME(LFN,NFN)
      CALL LOADER 
      CALL ALLOC(NRT) 
      CALL DIM(NRT,8) 
      CALL NPLOT(KXM,KYM,3) 
      CALL NPLOT(KXM,KYX,2) 
      CALL NPLOT(KXX,KYX,2) 
      IRD=IRT 
      LXM(IRD)=KXM
      LYM(IRD)=KYM
      LXX(IRD)=KXX
      LYX(IRD)=KYX
      CALL DRAW(IRD)
2     CALL TRACKR 
      CALL INZOOM 
      CALL INTEXT 
      CALL INCMND 
      GOTO 2
      END 
BLKDATA 
      BLOCK DATA
C 
C COMMON BLOCK /DATA/ 
C 
C     LNX(MDA) - NEXT LINK TO FOLLOWING STATEMENT 
C     LBT(MDA) - BROTHER LINK TO ALTERNATIVE STATEMENT
C     LSN(MDA) - SON LINK TO CONTAINED STATEMENT
C     LTY(MDA) - STATEMENT TYPE, 0=UNUSED, 1=PROC, 2=FOR, 
C         3=REP, 4=IF, 5=CASE, 6=ROOT 
C     LXM(MDA) - X MINIMUM (GRAPHICAL BOUNDRY)
C     LXX(MDA) - X MAXIMUM
C     LYM(MDA) - Y MINIMUM
C     LYX(MDA) - Y MAXIMUM
C     LSG(MDA) - ASSIGNED SEGMENT NUMBER, ZERO IF NONE. 
C     LTX(MTX,MDA) - STATEMENT TEXT IN A1 FORMAT
C     IRT - INDEX OF ROOT NODE
C     IRD - INDEX OF DISPLAY ROOT 
C     ICH - INDEX OF ROOT OF MODIFIED TREE, ZERO IF NO CHANGE 
C     IKP - INDEX OF REMOVED (KEPT) STATEMENT 
C     KXM - SCREEN X MINIMUM
C     KXX - SCREEN X MAXIMUM
C     KYM - SCREEN Y MINIMUM
C     KYX - SCREEN Y MAXIMUM
C 
*CALL,DATA
C 
C COMMON BLOCK /STACK/
C 
C     LST(MST) - STACK STORAGE AREA 
C     NST - STACK POINTER, PRE-INCREMENTS ON PUSH 
C 
*CALL,STACK 
C 
C COMMON BLOCK /SEGS/ 
C 
C     LSEG(100) - GRAFIC SEGMENT RESERVATION WORDS, 1:IN USE, 0:FREE
C 
*CALL,SEGS
C 
C COMMON BLOCK /FILE/ 
C 
C     NIO - I/O ERROR NUMBER FROM DOS 
C     NFN - NUMBER OF CHARACTERS IN FILE NAME 
C     LFN(MFN) - FILE NAME
C 
*CALL,FILE
C 
C INITIALIZATIONS 
C 
      DATA IRT,IRD,ICH,IKP/4*0/ 
      DATA KXM,KXX,KYM,KYX/95,928,0,1000/ 
      DATA MDA/100/, MTX/40/
      DATA MST,NST/200,0/ 
      DATA LSEG/100*0/
      DATA MFN,NFN/6,4/,LFN/1HM,1HA,1HI,1HN,0,0/
C 
      END 
DUMP
      SUBROUTINE DUMP 
C 
*CALL,DATA
*CALL,STACK 
*CALL,FILE
*CALL,MOUSE 
C 
C  PRINT POINTERS 
C 
      WRITE (6,4) IRT,IRD,IRF,IKP,(LFN(I),I=1,NFN)
4     FORMAT(/'  ROT DIS REF KEP  NAME'//4I4,2X,6A1)
C 
C  PRINT NON-NULL NODES 
C 
      WRITE(6,1)
1     FORMAT(/'  NAM NXT SON BTR TYP SEG XM   XX   YM   YX   TEXT'/)
      DO 3 I=1,MDA
      IF(LTY(I).NE.0) WRITE(6,2)
     +    I,LNX(I),LSN(I),LBT(I),LTY(I),
     +    LSG(I),LXM(I),LXX(I),LYM(I),LYX(I), 
     +    (LTX(I1,I),I1=1,MTX)
2     FORMAT(6I4,4I5,2X,40A1) 
3     CONTINUE
      WRITE (6,5) NST,(LST(I),I=1,NST)
5     FORMAT(/'  STACK ',I4//(10I6))
      RETURN
C 
      END 
DRAW
      SUBROUTINE DRAW(JRT)
C 
C  REGENERATE DISPLAY FROM ROOT JRT AND ITS SON 
C  SUBTREE.  JRT'S BOUNDS MUST BE DEFINED BY
C  THE CALLER.
C 
*CALL,DATA
*CALL,BOX 
      DIMENSION LPROC(9),LWHILE(15),LREPT(15),LIFTHN(15)
      DIMENSION LCASE(9),LCONEC(15) 
      DATA LPROC/1,1,3,3,1,2,3,3,-2/
      DATA LWHILE/1,1,3,2,1,2,2,2,2,3,2,2,3,3,-2/ 
      DATA LREPT/1,1,3,3,1,2,3,2,2,2,2,3,2,3,-2/
      DATA LIFTHN/1,2,3,3,2,2,3,3,2,2,2,2,1,3,-2/ 
      DATA LCASE/3,3,3,3,2,2,1,2,-2/
      DATA LCONEC/1,3,3,3,1,2,3,3,2,1,1,2,3,1,-2/ 
C 
C  STATEMENT FUNCTIONS
C 
      NWD(N)=MIN0(N/4,60) 
C 
C  INITIALIZE 
C 
      IND=JRT 
      CALL PUSH(0)
C 
C  SETUP FOR NEXT STATEMENT 
C 
102   ITY=LTY(IND)
      IF(ITY.EQ.0) CALL ERROR(7)
      IF(LSG(IND).EQ.0) CALL ALLOC(LSG(IND))
      CALL SEG(LSG(IND))
      CALL DIM(LSG(IND),8)
      NXM=LXM(IND)
      NXX=LXX(IND)
      NYM=LYM(IND)
      NYX=LYX(IND)
      NDX=NXX-NXM 
      NDY=NYX-NYM 
C 
      IF((NDX.LT.100.OR.NDY.LT.100).AND.ITY.NE.1) GOTO 200
      GOTO (210,220,230,240,250,260),ITY
C 
C  OFF PAGE CONNECTOR 
C 
200   CALL FORM(IND,LCONEC,0,0) 
      CALL FREDIS(LSN(IND),0) 
      GOTO 306
C 
C  PROCEDURE
C 
210   CALL FORM(IND,LPROC,0,0)
      NYT=(NYM+NYX)/2 
      GOTO 302
C 
C  WHILE, FOR 
C 
220   CALL FORM(IND,LWHILE,NWD(NDX),NDY-NWD(NDY)) 
      IPT=LSN(IND)
      CALL SETALL(LNX,IPT,LXM,LXX,NXM+NWD(NDX),NXX) 
      CALL SHARE(LNX,IPT,LYX,LYM,NYX-NWD(NDY),NYM)
      NYT=NYX-NWD(NDY)/2
      GOTO 302
C 
C  REPEAT 
C 
230   CALL FORM(IND,LREPT,NWD(NDX),NWD(NDY))
      IPT=LSN(IND)
      CALL SETALL(LNX,IPT,LXM,LXX,NXM+NWD(NDX),NXX) 
      CALL SHARE(LNX,IPT,LYX,LYM,NYX,NYM+NWD(NDY))
      NYT=NYM+NWD(NDY)/2
      GOTO 302
C 
C  IF THEN ELSE 
C 
240   CALL FORM(IND,LIFTHN,NDX/2,NDY-2*NWD(NDY))
      IPT=LSN(IND)
      CALL SETALL(LNX,IPT,LXM,LXX,NXM,(NXM+NXX)/2)
      CALL SHARE(LNX,IPT,LYX,LYM,NYX-2*NWD(NDY),NYM)
      IPT=LBT(IPT)
      CALL SETALL(LNX,IPT,LXM,LXX,(NXM+NXX)/2,NXX)
      CALL SHARE(LNX,IPT,LYX,LYM,NYX-2*NWD(NDY),NYM)
      NYT=NYX-NWD(NDY)/2
      GOTO 302
C 
C  CASE 
C 
250   N1=NWD(NDY) 
      CALL FORM(IND,LCASE,0,NDY-2*N1) 
      IPT=LSN(IND)
      CALL SHARE(LBT,IPT,LXM,LXX,NXM,NXX) 
252   CALL SETALL(LNX,IPT,LXM,LXX,LXM(IPT),LXX(IPT))
      CALL SHARE(LNX,IPT,LYX,LYM,NYX-2*N1,NYM)
      CALL NPLOT((LXM(IPT)+LXX(IPT))/2,NYX-N1,2)
      CALL NPLOT(LXX(IPT),NYX-2*N1,2) 
      IPT=LBT(IPT)
      IF(IPT.NE.0) GOTO 252 
      NYT=NYX-N1/2
      GOTO 302
C 
C  ROOT NODE
C 
260   CALL SETALL(LNX,LSN(IND),LXM,LXX,NXM,NXX) 
      CALL SHARE(LNX,LSN(IND),LYX,LYM,NYX,NYM)
      GOTO 304
C 
C  END OF STATEMENT PROCESSING
C 
302   CALL NPLOT(NXM+10,NYT-8,-3) 
      CALL MARK 
      CALL LABEL(IND) 
304   CALL PUSHNZ(LSN(IND)) 
306   IF(IND.EQ.JRT) GOTO 308 
      CALL PUSHNZ(LBT(IND)) 
      CALL PUSHNZ(LNX(IND)) 
308   CALL PULL(IND)
      IF(IND.NE.0) GOTO 102 
      RETURN
C 
      END 
FORM
      SUBROUTINE FORM(JN,JD,JX,JY)
C 
C  DISPLAY PREDEFINED FORM WITH OBJECT TIME SCALING.
C 
*CALL,DATA
*CALL,BOX 
      DIMENSION JD(3,5),NX(3),NY(3) 
C 
      NX(1)=LXM(JN) 
      NX(2)=NX(1)+JX
      NX(3)=LXX(JN) 
      NY(1)=LYM(JN) 
      NY(2)=NY(1)+JY
      NY(3)=LYX(JN) 
C 
      IF(NX(3)-NX(1).LT.1.OR.NY(3)-NY(1).LT.1) CALL ERROR(10) 
C 
C  PROCESSING LOOP
C 
      DO 102 I=1,5
      IX=JD(1,I)
      IY=JD(2,I)
      CALL NPLOT(NX(IX),NY(IY),IABS(JD(3,I))) 
      IF(JD(3,I).LT.0) RETURN 
102   CONTINUE
C 
      CALL ERROR(4) 
      RETURN
      END 
COUNTR
      SUBROUTINE COUNTR(JPT,JND,J)
      DIMENSION JPT(100)
C 
C  FOLLOW JPT CHAIN STARTING AT JND AND 
C  RETURN COUNT OF NODES IN J.
C 
*CALL,DATA
C 
      IND=JND 
      J=0 
      DO 102 I=1,MDA
      IF(IND.EQ.0) RETURN 
      IND=JPT(IND)
102   J=J+1 
      CALL ERROR(1) 
      RETURN
      END 
SETALL
      SUBROUTINE SETALL(JPT,JND,JAM,JAX,JM,JX)
      DIMENSION JPT(100),JAM(100),JAX(100)
C 
C  FOLLOW JPT CHAIN STARTING AT JND AND 
C  SET ALL JAX AND JAM TO JX AND JM RESPECTIVLY.
C 
*CALL,DATA
C 
      IND=JND 
      DO 102 I=1,MDA
      IF(IND.EQ.0) RETURN 
      JAX(IND)=JX 
      JAM(IND)=JM 
102   IND=JPT(IND)
      CALL ERROR(2) 
      RETURN
      END 
SHARE 
      SUBROUTINE SHARE(JPT,JND,JAM,JAX,JM,JX) 
      DIMENSION JPT(100),JAM(100),JAX(100)
C 
C  FOLLOW JPT CHAIN STARTING AT JND AND 
C  DIVIDE JM-JX EVENLY BETWEEN EACH NODE. 
C 
      IND=JND 
      CALL COUNTR(JPT,JND,N1) 
      NM=JM 
      ND=JX-JM
      DO 102 N2=1,N1
      IF(IND.EQ.0) CALL ERROR(3)
      JAM(IND)=NM 
      NM=JM+ND*N2/N1
      JAX(IND)=NM 
102   IND=JPT(IND)
      RETURN
      END 
PUSH
      SUBROUTINE PUSH(J)
C 
C  PUSH J ONTO OBJECT TIME STACK
C 
C  STACK ENTRY FORMATS
C 
C     TOP 
C 
C     (0)   - END OF STACK
C     (1) (ROOT)   - PREVIOUS DISPLAY ROOT
C     (2) (N) (NAME1) (NAME2) ... (NAMEN) (ROOT)  - PREVIOUS FILE 
C 
C        SINGLE ROUTINES MAY STORE INFORMATION IN OTHER 
C     THAN THE ABOVE FORMAT SO LONG AS IT IS REMOVED
C     BEFORE EXIT.
C 
*CALL,STACK 
      IF(NST.EQ.MST) CALL ERROR(5)
      NST=NST+1 
      LST(NST)=J
      RETURN
      END 
PUSHNZ
      SUBROUTINE PUSHNZ(J)
C 
C  STORE J ON OBJECT TIME STACK IF J IS NON-ZERO. 
C 
      IF(J.NE.0) CALL PUSH(J) 
      RETURN
      END 
PULL
      SUBROUTINE PULL(J)
C 
C  POP J FROM OBJECT TIME STACK 
C 
*CALL,STACK 
      IF(NST.EQ.0) CALL ERROR(6)
      J=LST(NST)
      NST=NST-1 
      RETURN
      END 
ALLOC 
      SUBROUTINE ALLOC(JS)
C 
C  ALLOCATE SEGMENT SPACE IN IMLAC. 
C 
*CALL,SEGS
C 
      DO 102 I=1,100
      IF(LSEG(I).EQ.0) GOTO 202 
102   CONTINUE
      CALL ERROR(11)
202   LSEG(I)=1 
      JS=I
      CALL SEG(JS)
      RETURN
      END 
FREE
      SUBROUTINE FREE(JS) 
C 
C  RETURN SEGMENT ALLOCATION IN IMLAC.
C  JS IS SET TO ZERO. 
C 
*CALL,SEGS
C 
      IF(LSEG(JS).NE.1) CALL ERROR(12)
      CALL SEG(-JS) 
      LSEG(JS)=0
      JS=0
      RETURN
      END 
NPLOT 
      SUBROUTINE NPLOT(JX,JY,JI)
C 
C  INTERGER VERSION OF SUBROUTINE PLOT
C 
      CALL PLOT(FLOAT(JX)/100.,FLOAT(JY)/100.,JI) 
      RETURN
      END 
TRACKR
      SUBROUTINE TRACKR 
C 
C  TRACK MOUSE ON DISPLAY AND INTENSIFY SMALLEST BOX
C  CONTAINING TRACKING SYMBOL.
C 
C  COMMON BLOCK /MOUSE/ 
C 
C     IRF - INDEX OF REFERENCED NODE
C     IFT - INDEX OF FATHER OF IRF, 0 IF NONE 
C     NXP, NYP - MOUSE POSITION IN SCREEN COORDINATES 
C 
*CALL,DATA
*CALL,MOUSE 
      DATA NSTR/0/
      DATA NXS,NYS/0,0/ 
      DATA NDLY/100/
C 
C  STATEMENT FUNCTIONS
C 
      COORD(N)=FLOAT(MIN0(MAX0(N,20),1003))/100.
C 
C  INITIALIZE ON FIRST CALL 
C 
      IF(NSTR.NE.0) GOTO 202
      CALL ALLOC(NSTR)
      CALL CIRCLE(0.,0.,.2,16)
C 
C  COMPUTE MOUSE POSITION WITH DAMPING
C 
202   CALL MOUSE(X,Y) 
      NXP=(4*NXP+MIN0(MAX0(IFIX(100.*X),KXM),KXX))/5
      NYP=(4*NYP+MIN0(MAX0(IFIX(100.*Y),KYM),KYX))/5
      CALL MOVE(NSTR,COORD(NXP),COORD(NYP)) 
C 
C  DISPLAY CURSOR ONLY WHEN NEEDED
C 
302   IF(NXP.NE.NXS) GOTO 304 
      IF(NYP.NE.NYS) GOTO 304 
      IF(ICH.NE.0) GOTO 304 
      IF(NDLY.LT.0) RETURN
      NDLY=NDLY-1 
      IF(NDLY.GE.0) GOTO 306
      CALL BLANK(NSTR)
      RETURN
304   IF(NDLY.LT.0) CALL BLANK(-NSTR) 
      NXS=NXP 
      NYS=NYP 
      NDLY=100
306   CONTINUE
C 
C  SEARCH DATA STRUCTURE FOR ENCLOSING BOX
C 
      IFT=0 
      IPT=IRD 
402   IF(IPT.EQ.0) GOTO 502 
      IF(LSG(IPT).EQ.0) GOTO 502
      IF(NXP.GT.LXX(IPT)) GOTO 406
      IF(NYP.LT.LYM(IPT)) GOTO 408
      IF(NXP.LT.LXM(IPT).OR.NYP.GT.LYX(IPT))GOTO 502
      IFT=IRF 
      IRF=IPT 
      IPT=LSN(IPT)
      GOTO 402
406   IPT=LBT(IPT)
      GOTO 402
408   IPT=LNX(IPT)
      GOTO 402
C 
C  INTENSIFY REFERENCED BOX 
C 
502   CALL BOX(IRF) 
      RETURN
      END 
LABEL 
      SUBROUTINE LABEL(JN)
C 
C  DISPLAY TEST FROM NODE JN
C 
*CALL,DATA
      DIMENSION LDIM(3) 
      DATA LDIM/11,13,15/ 
C 
C  ATTACH DISPLAY SEGMENT 
C 
      CALL APPEND(LSG(JN))
      CALL RESET
C 
C  MEASURE LINE LENGTH
C 
      DO 102 N1=1,MTX 
      N2=MTX-N1+1 
      IF(LTX(N2,JN).NE.1H ) GOTO 202
102   CONTINUE
      RETURN
C 
C  COMPUTE TEXT SIZE
C 
202   NDX=MAX0(LXX(JN)-LXM(JN)-20,6)
      NDY=MAX0(LYX(JN)-LYM(JN)-10,6)
      NS=MIN0(NDX/(N2*6),NDY/6,3) 
C 
C  PLOT STRING
C 
      IF(NS.NE.0) GOTO 302
      NS=1
      N2=NDX/6
302   CALL INTSTY(LDIM(NS)) 
      CALL NPLOT((NDX-6*NS*N2)/2,0,3) 
      DO 304 N1=1,N2
304   CALL STRING(NS,1,LTX(N1,JN))
      RETURN
      END 
INTEXT
      SUBROUTINE INTEXT 
C 
C  INPUT TEXT IN REFERENCED NODE
C 
*CALL,DATA
*CALL,MOUSE 
      DATA ION/0/ 
C 
C  LOOK FOR INPUT 
C 
      IF(ICH.NE.0) ION=0
      CALL KEYBRD(NC) 
      IF(NC.EQ.0) RETURN
C 
C  SELECT SEGMENT 
C 
      IF(ION.EQ.IRF) GOTO 202 
      ION=IRF 
      DO 102 N1=1,MTX 
      NL=MTX-N1+1 
      IF(LTX(NL,ION).NE.1H ) GOTO 202 
102   CONTINUE
      NL=0
C 
C  RECORD CHARACTER 
C 
202   IF(NC.EQ.13) GOTO 302 
      IF(NC.LE.31) RETURN 
      IF(NC.GE.96) NC=NC-32 
      IF(NL.EQ.0.AND.NC.EQ.32) RETURN 
      NL=MIN0(NL+1,MTX) 
      LTX(NL,ION)=(1H )-32+NC 
      GOTO 402
C 
C  BACKSPACE
C 
302   NL=MAX0(NL-1,0) 
      LTX(NL+1,ION)=(1H ) 
C 
C  DISPLAY MODIFIED TEXT
C 
402   CALL KEYBRD(NC) 
      IF(NC.NE.0) GOTO 202
      CALL LABEL(ION) 
      RETURN
      END 
INCMND
      SUBROUTINE INCMND 
C 
C  ENTER PROGRAM EDITING COMMANDS FROM THE KEYSET.
C 
C  COMMANDS ARE THE FOLLOWING:
C 
C      .  .  .  .  1  DISCARD KEPT STATEMENT
C      .  .  .  2  .  INSERT STATEMENT
C      .  .  .  2  1  REMOVE STATEMENT
C      .  .  4  .  .  EXPAND STATEMENT
C      .  .  4  .  1  CONTRACT STATEMENT
C      .  8  .  .  .  TRANSLATE 
C     16  .  .  .  .  DUMP TREE 
C     16  8  4  2  1  TERMINATE EDIT
C 
C 
*CALL,DATA
*CALL,MOUSE 
      DIMENSION LCMN(20)
      DATA LCMN/2,3,4,5,8,16,31,1,12*0/ 
C 
C  LOOK FOR KEYSET INPUT
C 
      ICH=0 
      CALL KEYSET(N2) 
      IF(N2.EQ.0) RETURN
      DO 102 N1=1,20
      IF(LCMN(N1).EQ.N2) GOTO 104 
102   CONTINUE
      RETURN
104   ICH=IRD 
      IF(IFT.NE.0) ICH=IFT
      GOTO (202,302,402,502,600,602,702,802),N1 
C 
C  INSERT PROC STATEMENT
C 
202   IF(IKP.EQ.0) CALL NEWNOD(IKP) 
      IF(NYP.GT.(LYX(IRF)+LYM(IRF))/2) GOTO 204 
      LNX(IKP)=LNX(IRF) 
      LNX(IRF)=IKP
      GOTO 206
204   CALL REFREP(IRF,IKP)
      LNX(IKP)=IRF
206   IKP=0 
      GOTO 902
C 
C  REMOVE STATEMENT (AND SON SUBTREE) 
C 
302   IS=LNX(IRF) 
      IF(IS.EQ.0) CALL NEWNOD(IS) 
      CALL REFREP(IRF,IS) 
      LNX(IRF)=0
      CALL FRETRE(IKP)
      IKP=IRF 
      CALL FREDIS(IKP,0)
      GOTO 902
C 
C  EXPAND STATEMENT 
C 
402   ICH=IRF 
      LTY(IRF)=MIN0(LTY(IRF)+1,5) 
      IF(LTY(IRF).EQ.3) GOTO 902
      IF(IKP.EQ.0) CALL NEWNOD(IKP) 
      IF(LTY(IRF).NE.2) GOTO 404
      LSN(IRF)=IKP
      GOTO 410
404   IS=LSN(IRF) 
      DO 406 I=1,MDA
      IF(LBT(IS).EQ.0) GOTO 408 
406   IS=LBT(IS)
      CALL ERROR(17)
408   LBT(IS)=IKP 
410   IKP=0 
      GOTO 902
C 
C  CONTRACT STATEMENT 
C 
502   IF(LTY(IRF).EQ.1) RETURN
      ICH=IRF 
      N=1 
      IN=0
      IS=LSN(IRF) 
504   IF(LBT(IS).EQ.0) GOTO 505 
      N=N+1 
      IN=IS 
      IS=LBT(IS)
      GOTO 504
505   IF(LTY(IRF).EQ.3) GOTO 508
      CALL FRETRE(IKP)
      IKP=IS
      CALL FRETRE(LNX(IKP)) 
      CALL FREDIS(IKP,0)
      IF(IN.EQ.0) GOTO 506
      LBT(IN)=0 
      GOTO 508
506   LSN(IRF)=0
508   IF(N.LE.3) LTY(IRF)=LTY(IRF)-1
      GOTO 902
C 
C  TRANSLATE TO FORTRAN 
C 
600   CALL TRANSL 
      RETURN
C 
C  DUMP TREE
C 
602   CALL DUMP 
      RETURN
C 
C  TERMINATE EDIT 
C 
702   CALL DUMPER 
      STOP
C 
C  DISCARD KEPT STATEMENT 
C 
802   CALL FRETRE(IKP)
      RETURN
C 
C  REGENERATE DISPLAY 
C 
902   CALL DRAW(ICH)
      RETURN
C 
      END 
FRENOD
      SUBROUTINE FRENOD(JN) 
C 
C  DEALLOCATE NODE JN 
C 
*CALL,DATA
C 
      IF(LTY(JN).EQ.0) CALL ERROR(20) 
      IF(LSG(JN).NE.0) CALL FREE(LSG(JN)) 
      LTY(JN)=0 
      RETURN
      END 
FRETRE
      SUBROUTINE FRETRE(JN) 
C 
C  DEALLOCATE NODE JN AND ALL NODES IN THE SUBTREE FOR WHICH IT 
C  IS THE ROOT.  JN IS SET TO NULL. 
C 
*CALL,DATA
C 
      IN=JN 
      IF(IN.EQ.0) RETURN
      CALL PUSH(0)
102   CALL PUSHNZ(LNX(IN))
      CALL PUSHNZ(LBT(IN))
      CALL PUSHNZ(LSN(IN))
      CALL FRENOD(IN) 
      CALL PULL(IN) 
      IF(IN.NE.0) GOTO 102
      JN=0
      RETURN
      END 
NEWNOD
      SUBROUTINE NEWNOD(JN) 
C 
C  ALLOCATE NEW NODE
C 
*CALL,DATA
C 
C  LOCATE UNUSED NODE 
C 
      DO 102 I=1,MDA
      IF(LTY(I).EQ.0) GOTO 202
102   CONTINUE
      CALL ERROR(16)
C 
C  CLEAR DATA FIELDS
C 
202   JN=I
      LTY(I)=1
      LNX(I)=0
      LBT(I)=0
      LSN(I)=0
      LXM(I)=0
      LXX(I)=0
      LYM(I)=0
      LYX(I)=0
      LSG(I)=0
C 
      DO 204 I=1,MTX
204   LTX(I,JN)=(1H ) 
C 
      RETURN
      END 
REFREP
      SUBROUTINE REFREP(JR,JN)
C 
C  REPLACE REFERENCE TO JR WITH JN.  JN MUST HAVE 
C  NULL BROTHER LINK. 
C 
*CALL,DATA
C 
      DO 102 I=1,MDA
      IF(LTY(I).EQ.0) GOTO 102
      IF(LNX(I).EQ.JR) GOTO 201 
      IF(LBT(I).EQ.JR) GOTO 202 
      IF(LSN(I).EQ.JR) GOTO 203 
102   CONTINUE
      CALL ERROR(21)
C 
201   LNX(I)=JN 
      RETURN
202   LBT(I)=JN 
      GOTO 302
203   LSN(I)=JN 
C 
302   IF(LBT(JN).NE.0) CALL ERROR(26) 
      LBT(JN)=LBT(JR) 
      LBT(JR)=0 
      RETURN
      END 
INZOOM
      SUBROUTINE INZOOM 
C 
C  INPUT MOUSE BUTTONS TO CONTROL DISPLAY.
C  SUBROUTINE INCLUDES SOFTWARE FILTERING AND EDGE DETECTION. 
C 
*CALL,MOUSE 
      DIMENSION LCH(3),LRF(3),LVA(3),LST(3) 
      DATA LCH/13,14,15/,LRF/1,0,-1/,LVA,LST/6*0/ 
C 
      LRF(1)=IRF
      DO 102 N=1,3
      CALL IDAS(LCH(N),N1)
      LVA(N)=(4*LVA(N)+(N1-400))/5
      IF(LST(N).GT.0) GOTO 102
      IF(LVA(N).GT.0) CALL ZOOM(LRF(N)) 
102   LST(N)=LVA(N) 
      RETURN
C 
      END 
ZOOM
      SUBROUTINE ZOOM(JN) 
C 
C  ADJUST DISPLAY ROOT IN A RETURNABLE FASHION. 
C  JN IS TO BECOME THE ROOT.  IF ZERO, THE PREVIOUS 
C  ROOT IS TO BE RESTORED.
C  IF NEGATIVE, ROOTS WILL BE RESTORED UNTIL THE
C  BEGINNING OF PROGRAM IS LOCATED. 
C 
*CALL,DATA
*CALL,FILE
      INTEGER LCALL(5)
      DATA LCALL/1HC,1HA,1HL,1HL,1H / 
C 
C  PUSH CURRENT ROOT ON STACK 
C 
      IF(JN.LE.0) GOTO 202
      IF(JN.EQ.IRD) GOTO 302
      CALL PUSH(IRD)
      CALL PUSH(1)
      IRD=JN
      GOTO 902
C 
C  POP OLD ROOT FROM STACK
C 
202   CALL PULL (IT)
      IF(IT.EQ.1) GOTO 204
      IF(IT.EQ.2) GOTO 402
      CALL PUSH(IT) 
      RETURN
204   CALL PULL(IRD)
      IF(JN.EQ.0) GOTO 902
      CALL PULL(IT) 
      IF(IT.EQ.1) GOTO 204
      CALL PUSH(IT) 
      GOTO 902
C 
C  PUSH FILE NAME ON STACK AND OPEN NEW ONE 
C 
302   IF(LTY(IRD).NE.1) RETURN
      DO 304 I1=1,5 
      IF(LTX(I1,IRD).NE.LCALL(I1)) RETURN 
304   CONTINUE
      CALL PUSH(IRD)
      DO 305 I1=1,NFN 
305   CALL PUSH(LFN(NFN-I1+1))
      CALL PUSH(NFN)
      CALL PUSH(2)
      DO 306 I1=6,11
      NC=LTX(I1,IRD)
      IF(NC.EQ.1H ) GOTO 308
      IF(NC.EQ.1H() GOTO 308
      NFN=I1-5
306   LFN(NFN)=NC 
308   CALL DUMPER 
      CALL FRETRE(IRT)
      CALL FRETRE(IKP)
      CALL RENAME(LFN,NFN)
      CALL LOADER 
      GOTO 902
C 
C  SAVE FILE AND POP BACK TO OLD ONE
C 
402   CALL DUMPER 
      CALL FRETRE(IRT)
      CALL FRETRE(IKP)
      CALL PULL(NFN)
      DO 404 I1=1,NFN 
404   CALL PULL(LFN(I1))
      CALL RENAME(LFN,NFN)
      CALL LOADER 
      CALL PULL(IRD)
      IF(LTY(IRD).EQ.0) CALL ERROR(29)
C     GOTO 902
C 
C  REDRAW DISPLAY 
C 
902   CALL FREDIS(IRT,IRD)
      LXM(IRD)=KXM
      LYM(IRD)=KYM
      LXX(IRD)=KXX
      LYX(IRD)=KYX
      CALL DRAW(IRD)
      RETURN
C 
      END 
FREDIS
      SUBROUTINE FREDIS(JF,JN)
C 
C  CLEAR DISPLAY SEGMENTS FOR SUBTREE HEADED BY JF. 
C  IF JN IS NON-ZERO, IT AND ITS SON SUBTREE WILL NOT 
C  BE CLEARED.
C 
*CALL,DATA
C 
      CALL PUSH(0)
      CALL PUSHNZ(JF) 
102   CALL PULL(IN) 
      IF(IN.EQ.0) RETURN
      CALL PUSHNZ(LBT(IN))
      CALL PUSHNZ(LNX(IN))
      IF(IN.EQ.JN) GOTO 102 
      IF(LSG(IN).NE.0) CALL FREE(LSG(IN)) 
      CALL PUSHNZ(LSN(IN))
      GOTO 102
C 
      END 
ERROR 
      SUBROUTINE ERROR(J) 
C 
C  REPORT INTERNAL ERROR
C 
      WRITE(6,102) J
102   FORMAT(//' INTERNAL ERROR NUMBER ',I3//)
      CALL DUMP 
      X=-1
      Y=SQRT(X) 
      PAUSE 777 
      RETURN
      END 
DUMPER
      SUBROUTINE DUMPER 
C 
C  WRITE IRT TREE TO LOCAL FILE 
C 
*CALL,DATA
C 
      CALL DELFIL(2)
      I=LSN(IRT)
      IF(LTY(I).EQ.1.AND.LTX(1,I).EQ.1H ) RETURN
      CALL PUSH(0)
      I=IRT 
102   CALL BOX(I) 
      WRITE(2,104) I,LNX(I),LSN(I),LBT(I),LTY(I),(LTX(I2,I),I2=1,MTX) 
104   FORMAT(5I4,2X,40A1) 
      CALL PUSHNZ(LNX(I)) 
      CALL PUSHNZ(LBT(I)) 
      CALL PUSHNZ(LSN(I)) 
      CALL PULL(I)
      IF(I.NE.0) GOTO 102 
      CALL BOX(IRD) 
      ENDFILE 2 
      RETURN
      END 
LOADER
      SUBROUTINE LOADER 
C 
C  READ TREE FROM LOCAL FILE.  NODE NAMES FROM FILE ARE PRESERVED.
C 
*CALL,DATA
*CALL,FILE
C 
      NIO=0 
      IRT=0 
      DO 102 I1=1,MDA 
      READ (2,101,END=104,ERR=202)
     +    I,LNX(I),LSN(I),LBT(I),LTY(I),(LTX(I2,I),I2=1,MTX)
101   FORMAT(5I4,2X,40A1) 
      IF(I.LE.0.OR.I.GT.MDA) CALL ERROR(22) 
      IF(LTY(I).EQ.6) IRT=I 
      LXM(I)=0
      LXX(I)=0
      LYM(I)=0
      LYX(I)=0
102   LSG(I)=0
      I1=MDA
      CALL ERROR(23)
104   ENDFILE 2 
      IF(I1.NE.1) GOTO 302
C 
C  EMPTY FILE, CREATE NULL PROGRAM
C 
202   IF(NIO.NE.0) WRITE(6,204) NIO 
204   FORMAT(/' I/O ERROR NUMBER ',I3)
206   CALL NEWNOD(IRT)
      LTY(IRT)=6
      CALL NEWNOD(LSN(IRT)) 
C 
C  RESET POINTERS 
C 
302   IF(IRT.EQ.0) CALL ERROR(25) 
      IRD=IRT 
      ICH=IRT 
      RETURN
C 
      END 
RENAME
      SUBROUTINE RENAME(JF,JL)
C 
C  CHANGE DOS FILENAME FOR UNIT 2.
C  UPDATE SCREEN HEADING. 
C 
*CALL,DATA
*CALL,FILE
      INTEGER JF(JL)
      INTEGER LNAME(6)
      INTEGER LEXT(5,2),LUN(2)
      DATA LEXT/1H.,1HG,1HP,1HL,0,
     +          1H.,1HF,1HT,1HN,0/
      DATA LUN/2,3/ 
      DATA NAMS/0/
C 
      IF (JL.LE.0.OR.JL.GT.6) CALL ERROR(24)
      DO 106 N=1,2
      ENCODE(12,102,LNAME) (JF(N1),N1=1,JL),(LEXT(N1,N),N1=1,4) 
102   FORMAT(12A1)
106   CALL ASSIGN(LUN(N),LNAME,JL+4,NIO)
      IF(NAMS.EQ.0) CALL ALLOC(NAMS)
      CALL SEG(NAMS)
      CALL NPLOT(KXM,KYX+5,3) 
      CALL STRING(3,JL,LNAME) 
      RETURN
      END 
TRANSL
      SUBROUTINE TRANSL 
C 
C  TRANSLATE DATA STRUCTURE TO A FORTRAN PROGRAM
C  OUTPUT WILL BE ON UNIT 3.
C 
*CALL,DATA
      INTEGER LIFNOT(10),LTHEN(9),LGOTO(6),LDO(4),
     +  LOPAR(2),LCOMMA(2),LCPAR(2),LEND(4) 
      DATA LIFNOT/1HI,1HF,1H(,1H.,1HN,1HO,1HT,1H.,1H(,0/
      DATA LTHEN/1H),1H),1H ,1HG,1HO,1HT,1HO,1H ,0/ 
      DATA LGOTO/1HG,1HO,1HT,1HO,1H ,0/ 
      DATA LDO/1HD,1HO,1H ,0/ 
      DATA LOPAR/1H(,0/ 
      DATA LCOMMA/1H,,0/
      DATA LCPAR/1H),0/ 
      DATA LEND/1HE,1HN,1HD,0/
C 
C  INITIALIZE 
C 
      CALL PUSH(0)
      CALL DELFIL(3)
      IN=IRT
      NA=1
      GOTO 202
C 
C  RECURSIVE LOOP ENTRY 
C 
102   CALL PUSH(NF) 
      CALL PUSH(NS) 
C 
C  ENTER CODE GENERATOR FOR EACH STATEMENT
C 
202   CALL PUSH(IN) 
      NS=LTY(IN)
      CALL BOX(IN)
      GOTO (310,320,330,340,350,360),NS 
C 
C  PROCDURAL STATEMENT
C 
310   CALL GEN(LTX(1,IN),0,0,0) 
      GOTO 902
C 
C  WHILE STATEMENT
C 
320   NF=NA 
      NA=NA+2 
      CALL DEF(NF)
      CALL GEN(LIFNOT,LTX(1,IN),LTHEN,NF+1) 
      NS=1
      IN=LSN(IN)
      GOTO 102
322   CALL GEN(LGOTO,NF,0,0)
      CALL DEF(NF+1)
      GOTO 902
C 
C  REPEAT OR DO STATEMENT 
C 
330   NF=NA 
      NA=NA+1 
      DO 332 N=1,MTX
      IF(LTX(N,IN).EQ.1H=) GOTO 336 
332   CONTINUE
      CALL DEF(NF)
      NS=2
      IN=LSN(IN)
      GOTO 102
334   CALL GEN(LIFNOT,LTX(1,IN),LTHEN,NF) 
      GOTO 902
C 
C  DO STATEMENT (CONT)
C 
336   CALL GEN(LDO,NF,LTX(1,IN),0)
      NS=3
      IN=LSN(IN)
      GOTO 102
338   CALL DEF(NF)
      GOTO 902
C 
C  IF-THEN-ELSE STATEMENT 
C 
340   NF=NA 
      NA=NA+2 
      CALL GEN(LIFNOT,LTX(1,IN),LTHEN,NF) 
      NS=4
      IN=LSN(IN)
      GOTO 102
342   CALL GEN(LGOTO,NF+1,0,0)
      CALL DEF(NF)
      NS=5
      IN=LSN(IN)
      IN=LBT(IN)
      GOTO 102
344   CALL DEF(NF+1)
      GOTO 902
C 
C  CASE STATEMENT 
C 
350   CALL COUNTR(LBT,LSN(IN),NC) 
      NF=NA 
      NL=NA+NC
      NA=NA+NC+1
      CALL GENOUT(LGOTO)
      CALL GENOUT(LOPAR)
      DO 352 N=1,NC 
      CALL GENOUT(NF+N-1) 
      IF(N.NE.NC) CALL GENOUT(LCOMMA) 
352   CONTINUE
      CALL GEN(LCPAR,LCOMMA,LTX(1,IN),0)
      IP=LSN(IN)
354   CALL DEF(NF)
      NF=NF+1 
      NS=6
      IN=IP 
      CALL PUSH(NL) 
      CALL PUSH(IP) 
      GOTO 102
356   CALL PULL(IP) 
      CALL PULL(NL) 
      CALL GEN(LGOTO,NL,0,0)
      IP=LBT(IP)
      IF(IP.NE.0) GOTO 354
      CALL DEF(NL)
      GOTO 902
C 
C  ROOT 
C 
360   NS=7
      IN=LSN(IN)
      GOTO 102
362   CALL GEN(LEND,0,0,0)
C 
C  END OF STATEMENT PROCESSING
C 
902   CALL PULL(IN) 
      IN=LNX(IN)
      IF(IN.NE.0) GOTO 202
C 
C  END OF CLAUSE
C 
      CALL PULL(NS) 
      IF(NS.EQ.0) GOTO 904
      CALL PULL(NF) 
      CALL PULL(IN) 
      CALL PUSH(IN) 
      CALL BOX(IN)
      GOTO (322,334,338,342,344,356,362),NS 
C 
C  END OF PROGRAM 
C 
904   CALL BOX(IRD) 
      ENDFILE 3 
      RETURN
      END 
GEN 
      SUBROUTINE GEN(J1,J2,J3,J4) 
C 
C  GENERATE UP TO FOUR TEXT STRINGS.
C  OUTPUT IS FOLLOWED BY AN END OF LINE.
C  SEE GENOUT.
C 
      CALL GENOUT(J1) 
      IF(J1.EQ.0) RETURN
      CALL GENOUT(J2) 
      IF(J2.EQ.0) RETURN
      CALL GENOUT(J3) 
      IF(J3.EQ.0) RETURN
      CALL GENOUT(J4) 
      IF(J4.EQ.0) RETURN
      CALL GENOUT(0)
      RETURN
      END 
GENOUT
      SUBROUTINE GENOUT(JT) 
C 
C  ASSEMBLE OUTPUT LINE.
C 
C     JT=0  - END OF LINE.
C     JT<256  - OUTPUT NUMBER.
C     JT>=256  - TEXT ARRAY UP TO ZERO OR LAST NON-BLANK. 
C 
*CALL,DATA
      INTEGER JT(40)
      INTEGER LL(66),LB(6)
      DATA NL/0/
C 
C  CLASSIFY DATA TYPE 
C 
      IF(JT(1).EQ.0) GOTO 402 
      IF(JT(1).LE.256) GOTO 302 
      DO 102 N=2,MTX
      NC=N-1
      IF(JT(NC).EQ.0) GOTO 202
102   CONTINUE
      DO 104 N=1,MTX
      NC=MTX-N+1
      IF(JT(NC).NE.1H ) GOTO 202
104   CONTINUE
C 
C  MOVE TEXT INTO BUFFER
C 
202   DO 204 N=1,NC 
      NL=NL+1 
204   LL(NL)=JT(N)
      RETURN
C 
C  ENCODE DECIMAL NUMBER
C 
302   CALL PUSH(0)
      N=JT(1) 
304   CALL PUSH((1H0)+MOD(N,10))
      N=N/10
      IF(N.NE.0) GOTO 304 
306   CALL PULL(N)
      IF(N.EQ.0) RETURN 
      NL=NL+1 
      LL(NL)=N
      GOTO 306
C 
C  FLUSH LINE 
C 
402   IF(NC.LT.1) CALL ERROR(28)
      WRITE(3,404) (LL(N),N=1,NL) 
404   FORMAT(6X,66A1) 
      NL=0
      RETURN
      END 
DEF 
      SUBROUTINE DEF(JN)
C 
C  DEFINE STATEMENT NUMBER. 
C  THIS ROUTINE IS INTENDED TO COMMUNICATE WITH GENOUT
C  TO COMBINE NUMBERS WITH STATEMENTS, GENERATING 
C  CONTINUES ONLY WHEN REQUIRED.
C 
      WRITE (3,104) JN
104   FORMAT(I5,9H CONTINUE)
      RETURN
      END 
